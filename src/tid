#!/bin/bash
# tid - Terminal Identity CLI
# Manage terminal identity icons
# Compatible with bash 3.2+ and zsh

set -e

# Configuration paths
TID_CONFIG_DIR="${XDG_CONFIG_HOME:-$HOME/.config}/terminal-id"
TID_DATA_DIR="${XDG_DATA_HOME:-$HOME/.local/share}/terminal-id"
TID_RULES_FILE="$TID_CONFIG_DIR/rules.toml"
TID_IDENTITIES_FILE="$TID_CONFIG_DIR/identities.toml"

# Named identities - name|emoji|description
# These can be used with `tid set` and directory rules
TID_DEFAULTS="
bolt|âš¡|Fast, performance, or scripts
bug|ğŸ›|Debugging or bug fixes [reserved]
cloud|â˜ï¸|Cloud, AWS, or remote systems
database|ğŸ—„ï¸|Database or data projects
docker|ğŸ³|Docker or container projects
docs|ğŸ“š|Documentation projects
fire|ğŸ”¥|Hot, active, or urgent work
gear|âš™ï¸|Infrastructure, config, or tooling
gem|ğŸ’|Ruby or precious projects
go|ğŸ¹|Go/Golang projects
heart|â¤ï¸|Personal or passion projects
home|ğŸ |Home directory or personal
lock|ğŸ”’|Security or authentication [reserved]
node|ğŸ“¦|Node.js or package projects
python|ğŸ|Python projects
robot|ğŸ¤–|AI, automation, or bots
rocket|ğŸš€|Launch, deploy, or API projects
rust|ğŸ¦€|Rust projects
star|â­|Important or favorite projects
success|âœ…|Completed or stable projects [reserved]
test|ğŸ§ª|Testing or experiments
tree|ğŸŒ³|Frontend, UI, or growth projects
warning|âš ï¸|Production or danger zones [reserved]
work|ğŸ’¼|Work or professional projects
"

# Reserved icons (never auto-assigned, only via rules/manual)
TID_RESERVED="warning lock success bug"

# Auto-assign pool - icons available for automatic session assignment
# Includes most named identities plus expanded set (~80 total)
TID_AUTO_POOL="ğŸš€ ğŸŒ³ âš™ï¸ âš¡ â˜ï¸ ğŸ—„ï¸ ğŸ³ ğŸ“š ğŸ”¥ ğŸ’ ğŸ¹ â¤ï¸ ğŸ  ğŸ“¦ ğŸ ğŸ¤– ğŸ¦€ â­ ğŸ§ª ğŸ’¼ ğŸŒ¸ ğŸŒº ğŸŒ» ğŸŒ· ğŸŒ¹ ğŸ€ ğŸŒµ ğŸ‹ ğŸ ğŸ„ ğŸ¦‹ ğŸ ğŸ ğŸ¦Š ğŸ¦ ğŸ¯ ğŸ¦„ ğŸ™ ğŸ¦‘ ğŸ¦ ğŸª ğŸ­ ğŸ¨ ğŸ¯ ğŸ² ğŸ³ ğŸ¸ ğŸº ğŸ» ğŸ¥ ğŸš‚ â›µ ğŸš ğŸ  ğŸ¡ ğŸ¢ â›±ï¸ ğŸ–ï¸ ğŸ”ï¸ ğŸ—» ğŸ”® ğŸ€ ğŸ ğŸ† ğŸ–ï¸ ğŸ§© ğŸª ğŸˆ ğŸ ğŸª· ğŸ ğŸ‚ ğŸŒ¾ ğŸŒ´ ğŸª» ğŸª¸ ğŸ¦© ğŸ¦š ğŸ¦œ"
TID_AUTO_POOL_COUNT=80

# Check if identity is reserved
is_reserved() {
    local name="$1"
    case " $TID_RESERVED " in
        *" $name "*) return 0 ;;
        *) return 1 ;;
    esac
}

# Get emoji for a default identity
get_default_emoji() {
    local name="$1"
    echo "$TID_DEFAULTS" | while IFS='|' read -r n e d; do
        if [ "$n" = "$name" ]; then
            echo "$e"
            return 0
        fi
    done
}

# Check if identity exists in defaults
identity_exists() {
    local name="$1"
    echo "$TID_DEFAULTS" | grep -q "^${name}|"
}

# Ensure config directory exists
ensure_config_dir() {
    mkdir -p "$TID_CONFIG_DIR"
}

# Show usage
usage() {
    cat << 'EOF'
tid - Terminal Identity CLI

Usage:
    tid set <identity>              Set session identity (e.g., tid set rocket)
    tid unset                       Remove session identity override
    tid current                     Show current identity and source
    tid list                        List all available identities
    tid rule <path> <identity>      Add a directory rule
    tid rules                       List all directory rules
    tid rule-remove <path>          Remove a directory rule
    tid help                        Show this help message

Examples:
    tid set rocket                  Set current session to rocket icon
    tid rule ~/projects/api rocket  Always use rocket for ~/projects/api
    tid list                        Show all available identities

Directory Icons:
    Each directory gets a consistent icon from a pool of ~80 emojis.
    The same directory always shows the same icon across all terminals.

Environment:
    TID_IDENTITY                    Manual identity override
EOF
}

# List all identities
cmd_list() {
    echo "Named identities (for rules and 'tid set'):"
    echo ""

    # Display default identities
    echo "$TID_DEFAULTS" | while IFS='|' read -r name emoji desc; do
        if [ -n "$name" ]; then
            if is_reserved "$name"; then
                printf "  %-12s %s  %s\n" "$name" "$emoji" "$desc"
            else
                printf "  %-12s %s  %s\n" "$name" "$emoji" "$desc"
            fi
        fi
    done

    # Check for custom identities
    if [ -f "$TID_IDENTITIES_FILE" ]; then
        echo ""
        echo "Custom identities (from $TID_IDENTITIES_FILE):"
        current_section=""
        while IFS= read -r line; do
            case "$line" in
                \[*\])
                    current_section="${line#[}"
                    current_section="${current_section%]}"
                    ;;
                emoji\ =\ \"*\"|emoji=\"*\")
                    if [ -n "$current_section" ]; then
                        emoji="${line#*\"}"
                        emoji="${emoji%\"*}"
                        if ! identity_exists "$current_section"; then
                            printf "  %-12s %s\n" "$current_section" "$emoji"
                        fi
                    fi
                    ;;
            esac
        done < "$TID_IDENTITIES_FILE"
    fi

    echo ""
    echo "Reserved icons (rules only, not used for directory fallback):"
    echo "  warning, lock, success, bug"
    echo ""
    echo "Directory icon pool: $TID_AUTO_POOL_COUNT icons for directory-based assignment"
}

# Get emoji for any identity (default or custom)
get_emoji() {
    local name="$1"
    local emoji

    # Check defaults first
    emoji=$(echo "$TID_DEFAULTS" | while IFS='|' read -r n e d; do
        if [ "$n" = "$name" ]; then
            echo "$e"
            break
        fi
    done)

    if [ -n "$emoji" ]; then
        echo "$emoji"
        return 0
    fi

    # Check custom identities
    if [ -f "$TID_IDENTITIES_FILE" ]; then
        in_section=0
        while IFS= read -r line; do
            case "$line" in
                \["$name"\])
                    in_section=1
                    ;;
                \[*\])
                    in_section=0
                    ;;
                emoji\ =\ \"*\"|emoji=\"*\")
                    if [ "$in_section" = "1" ]; then
                        emoji="${line#*\"}"
                        emoji="${emoji%\"*}"
                        echo "$emoji"
                        return 0
                    fi
                    ;;
            esac
        done < "$TID_IDENTITIES_FILE"
    fi

    return 1
}

# Set session identity
cmd_set() {
    local identity="$1"

    if [ -z "$identity" ]; then
        echo "Error: identity name required"
        echo "Usage: tid set <identity>"
        echo "Run 'tid list' to see available identities"
        exit 1
    fi

    # Verify identity exists
    if ! identity_exists "$identity"; then
        if [ ! -f "$TID_IDENTITIES_FILE" ] || ! grep -q "^\[$identity\]" "$TID_IDENTITIES_FILE" 2>/dev/null; then
            echo "Error: unknown identity '$identity'"
            echo "Run 'tid list' to see available identities"
            exit 1
        fi
    fi

    local emoji
    emoji=$(get_emoji "$identity")

    echo "Setting identity to: $identity $emoji"
    echo ""
    echo "Run this command to apply:"
    echo "  export TID_IDENTITY='$identity'"
    echo ""
    echo "Or add to your shell rc file for persistence."

    # Export for current process
    export TID_IDENTITY="$identity"
}

# Unset session identity
cmd_unset() {
    echo "Removing identity override."
    echo ""
    echo "Run this command to apply:"
    echo "  unset TID_IDENTITY"

    unset TID_IDENTITY
}

# Show current identity
cmd_current() {
    local identity=""
    local emoji=""
    local source=""

    # Check TID_IDENTITY (manual override)
    if [ -n "$TID_IDENTITY" ]; then
        identity="$TID_IDENTITY"
        emoji=$(get_emoji "$identity")
        source="manual override (TID_IDENTITY)"
    fi

    # Check directory rules
    if [ -z "$identity" ] && [ -f "$TID_RULES_FILE" ]; then
        local dir="$PWD"
        while IFS= read -r line; do
            case "$line" in
                \#*|"") continue ;;
            esac

            case "$line" in
                \"*\"\ =\ \"*\"|\"*\"=\"*\")
                    rule_path="${line#\"}"
                    rule_path="${rule_path%%\"*}"
                    rule_identity="${line##*= \"}"
                    rule_identity="${rule_identity%\"*}"

                    case "$rule_path" in
                        \~*) rule_path="$HOME${rule_path#\~}" ;;
                    esac

                    case "$dir" in
                        "$rule_path"|"$rule_path"/*)
                            identity="$rule_identity"
                            emoji=$(get_emoji "$identity")
                            source="directory rule ($rule_path)"
                            break
                            ;;
                    esac
                    ;;
            esac
        done < "$TID_RULES_FILE"
    fi

    # Check git root rules
    if [ -z "$identity" ]; then
        local git_root
        git_root=$(git rev-parse --show-toplevel 2>/dev/null) || git_root=""
        if [ -n "$git_root" ] && [ -f "$TID_RULES_FILE" ]; then
            while IFS= read -r line; do
                case "$line" in
                    \#*|"") continue ;;
                esac

                case "$line" in
                    \"*\"\ =\ \"*\"|\"*\"=\"*\")
                        rule_path="${line#\"}"
                        rule_path="${rule_path%%\"*}"
                        rule_identity="${line##*= \"}"
                        rule_identity="${rule_identity%\"*}"

                        case "$rule_path" in
                            \~*) rule_path="$HOME${rule_path#\~}" ;;
                        esac

                        if [ "$git_root" = "$rule_path" ]; then
                            identity="$rule_identity"
                            emoji=$(get_emoji "$identity")
                            source="git root rule ($rule_path)"
                            break
                        fi
                        ;;
                esac
            done < "$TID_RULES_FILE"
        fi
    fi

    # Fallback: directory-based icon
    if [ -z "$emoji" ]; then
        local hash
        hash=$(echo "$PWD" | cksum | cut -d' ' -f1)
        local idx=$((hash % TID_AUTO_POOL_COUNT))
        emoji=$(echo "$TID_AUTO_POOL" | tr ' ' '\n' | sed -n "$((idx + 1))p")
        source="directory hash ($PWD)"
    fi

    if [ -n "$identity" ]; then
        echo "Current identity: $identity $emoji"
    else
        echo "Current icon: $emoji"
    fi
    echo "Source: $source"
}

# Add a directory rule
cmd_rule() {
    local path="$1"
    local identity="$2"

    if [ -z "$path" ] || [ -z "$identity" ]; then
        echo "Error: path and identity required"
        echo "Usage: tid rule <path> <identity>"
        exit 1
    fi

    # Expand path
    case "$path" in
        \~*) path="$HOME${path#\~}" ;;
    esac

    # Resolve to absolute path if it exists
    if [ -d "$path" ]; then
        path=$(cd "$path" && pwd)
    fi

    # Verify identity exists
    if ! identity_exists "$identity"; then
        if [ ! -f "$TID_IDENTITIES_FILE" ] || ! grep -q "^\[$identity\]" "$TID_IDENTITIES_FILE" 2>/dev/null; then
            echo "Error: unknown identity '$identity'"
            echo "Run 'tid list' to see available identities"
            exit 1
        fi
    fi

    ensure_config_dir

    # Remove existing rule for this path if any
    if [ -f "$TID_RULES_FILE" ]; then
        grep -v "^\"$path\"" "$TID_RULES_FILE" > "$TID_RULES_FILE.tmp" 2>/dev/null || true
        mv "$TID_RULES_FILE.tmp" "$TID_RULES_FILE"
    fi

    # Add header if file is new or empty
    if [ ! -f "$TID_RULES_FILE" ] || [ ! -s "$TID_RULES_FILE" ]; then
        echo "# Terminal Identity Rules" > "$TID_RULES_FILE"
        echo "# Format: \"path\" = \"identity\"" >> "$TID_RULES_FILE"
        echo "" >> "$TID_RULES_FILE"
    fi

    # Add the rule
    echo "\"$path\" = \"$identity\"" >> "$TID_RULES_FILE"

    local emoji
    emoji=$(get_emoji "$identity")
    echo "Added rule: $path -> $identity $emoji"
}

# List rules
cmd_rules() {
    if [ ! -f "$TID_RULES_FILE" ]; then
        echo "No rules configured."
        echo "Add rules with: tid rule <path> <identity>"
        exit 0
    fi

    echo "Directory rules:"
    echo ""

    while IFS= read -r line; do
        case "$line" in
            \#*|"") continue ;;
        esac

        case "$line" in
            \"*\"\ =\ \"*\"|\"*\"=\"*\")
                rule_path="${line#\"}"
                rule_path="${rule_path%%\"*}"
                rule_identity="${line##*= \"}"
                rule_identity="${rule_identity%\"*}"
                emoji=$(get_emoji "$rule_identity")
                printf "  %-40s -> %s %s\n" "$rule_path" "$rule_identity" "$emoji"
                ;;
        esac
    done < "$TID_RULES_FILE"
}

# Remove a rule
cmd_rule_remove() {
    local path="$1"

    if [ -z "$path" ]; then
        echo "Error: path required"
        echo "Usage: tid rule-remove <path>"
        exit 1
    fi

    if [ ! -f "$TID_RULES_FILE" ]; then
        echo "No rules configured."
        exit 1
    fi

    # Expand path
    case "$path" in
        \~*) path="$HOME${path#\~}" ;;
    esac

    if [ -d "$path" ]; then
        path=$(cd "$path" && pwd)
    fi

    if grep -q "^\"$path\"" "$TID_RULES_FILE" 2>/dev/null; then
        grep -v "^\"$path\"" "$TID_RULES_FILE" > "$TID_RULES_FILE.tmp"
        mv "$TID_RULES_FILE.tmp" "$TID_RULES_FILE"
        echo "Removed rule for: $path"
    else
        echo "No rule found for: $path"
        exit 1
    fi
}

# Main command dispatch
main() {
    local cmd="${1:-help}"
    shift 2>/dev/null || true

    case "$cmd" in
        set)
            cmd_set "$@"
            ;;
        unset)
            cmd_unset
            ;;
        current)
            cmd_current
            ;;
        list)
            cmd_list
            ;;
        rule)
            cmd_rule "$@"
            ;;
        rules)
            cmd_rules
            ;;
        rule-remove)
            cmd_rule_remove "$@"
            ;;
        help|--help|-h)
            usage
            ;;
        *)
            echo "Unknown command: $cmd"
            echo ""
            usage
            exit 1
            ;;
    esac
}

main "$@"
